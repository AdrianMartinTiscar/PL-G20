package ascendente.analizadorSintactico;

import java_cup.runtime.*;
import ascendente.analizadorLexico.AnalizadorLexicoTiny1;
import ascendente.analizadorLexico.UnidadLexica;
import ascendente.gestionErroresTinyGestionErr;

import procesamiento.SemOps;
import procesamiento.TinyASint.Bloque_vacio;
import procesamiento.TinyASint.Campo;
import procesamiento.TinyASint.Campos;
import procesamiento.TinyASint.Dec;
import procesamiento.TinyASint.Inst;
import procesamiento.TinyASint.InstrOp;
import procesamiento.TinyASint.Insts;
import procesamiento.TinyASint.LExpresiones;
import procesamiento.TinyASint.LParamForm;
import procesamiento.TinyASint.ParamD;
import procesamiento.TinyASint.ParamForm;
import procesamiento.TinyASint.Prog;
import procesamiento.TinyASint.StringLocalizado;
import procesamiento.TinyASint.Tipo;
import procesamiento.TinyASint.Decs;
import procesamiento.TinyASint.Exp;
import procesamiento.TinyASint.ParReales;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErr errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErr();
   AnalizadorLexicoTiny1 alex = (AnalizadorLexicoTiny1)getScanner();
   alex.fijaGestionErrores(errores);
:};

terminal  ID, NENT, NREAL, PAP, PCIERRE, IGUAL, TRUE, FALSE,
	 AND, OR, NOT, MENOR, MENORIGUAL, MAYOR, MAYORIGUAL, COMPARACION,
	 DISTINTO, MAS, MENOS, MUL, DIV, SEP, PTOCOMA, INT, REAL, BOOL,
	LITERALCAD, MODULO, CORABIERTO, CORCERRADO, LLAVEABIERTA, LLAVECERRADA,
	PUNTO, FLECHA, COMA, AMP, STRING, NULL, PROC, IF, THEN, ELSE, ENDIF, WHILE,
	DO, ENDWHILE, CALL, RECORD, ARRAY, OF, POINTER, NEW, DELETE, READ, WRITE,
	NL, VAR, TYPE;

terminal     StringLocalizado ID, LITERALCAD, NENT, NREAL;


non terminal  Programa Programa;
non terminal  Decs Decs;
non terminal  Dec Dec; 
non terminal  ParamForm ParamForm;
non terminal  Parametro Parametro;
non terminal  ListParamForm ListParamForm;
non terminal  Bloque bloque;
non terminal  Tipo tipo, tarray, trecord, tpointer;
non terminal  Campos campos;
non terminal  Campo campo;
non terminal  Instrucciones Instrucciones;
non terminal  Inst Inst;
non terminal  InstOp InstOp;
non terminal  ParReales paramReales;
non terminal  ListaExpresiones ListaExpresiones;
non terminal  Expresion Expresion, E0, E1, E2, E3, E4, E5, E6, E7;
non terminal  String OP1, OP2, OP3;

Programa ::= Decs: ds SEP Instrucciones 
	{:RESULT = sem.programa_conDecs(ds, is);:};
Programa ::= Instrs:is
    {:RESULT = sem.programa_sinDecs(is);:};
Decs ::= Dec: d PTOCOMA Decs: ds
    {:RESULT = sem.declaracion_varias(d, ds);:};
Dec ::= VAR tipo: t ID: i
    {:RESULT = sem.dec_habitual(t, i);:};
Dec ::= TYPE tipo:t ID:i
    {:RESULT = sem.dec_type(t, sem.tipoin(i));:};
Dec ::= PROC ID:i ParamForm:p bloque:b
    {:RESULT = sem.dec_proc(i, p, b);:};
ParamForm ::= PAP Parametro:p ListParamForm:l PCIERRE 
    {:RESULT = sem.param_formAux(p, l);:};
ListParamForm ::= COMA Parametro:p ListParamForm:l 
    {:RESULT = sem.lparamFormAux(p, l);:};
ListParamForm ::= 
    {:RESULT = null;:};
Parametro ::= tipo:t AMP ID:i 
    {:RESULT = sem.paramD(t, i);:};
Parametro ::= 
    {:RESULT = null;:};
bloque ::= LLAVEABIERTA Programa:p LLAVECERRADA
    {:RESULT = sem.bloque(p);:};
bloque ::= LLAVECERRADA  LLAVECERRADA
    {:RESULT = sem.bloque_vacio();:};

tipo ::= INT
    {:RESULT = sem.intt();:};
tipo ::= BOOL
    {:RESULT = sem.boolt();:};
tipo ::= REAL
    {:RESULT = sem.realt();:};
tipo ::= STRING
    {:RESULT = sem.stringt();:};

tipo ::= ARRAY CORABIERTO NENT:n CORCERRADO OF tipo: t
    {:RESULT =sem.tArray(n, t);:};
tipo ::= RECORD LLAVEABIERTA campo: c campos: cs LLAVECERRADA
    {:RESULT = sem.trecordAux(c, cs);:};
campos ::= PTOCOMA campo: c campos: cs
    {:RESULT = sem.campos(c, cs);:};
campos ::= 
    {:RESULT = null;:};
campo ::= tipo:t ID:i
    {:RESULT = sem.campo(t, i);:};
tipo ::= POINTER tipo:t
    {:RESULT = sem.tPointer(t);:};

Instrucciones ::= Inst:i PTOCOMA Instrucciones:is
    {:RESULT = sem.instruccion_varias(i, is);:};
Instrucciones ::= Inst
    {:RESULT = sem.instruccion_una(i);:};

Inst ::= expr:e0 IGUAL expr:e2
    {:RESULT = sem.instruccion_asig(e0, e2);:};
Inst ::= IF expr:e THEN InstOp:i ENDIF
    {:RESULT = sem.instruccion_ifAux(e,i);:};
Inst ::= IF expr:e THEN InstOp:i1 ELSE InstOp:i2 ENDIF
    {:RESULT = sem.instruccion_ifelseAux(e, i1, i2);:};

InstOp ::= Instrucciones
    {:RESULT = sem.instrOp_varias(is);:};
instrOpt ::= 
    {:RESULT = null;:};

Inst ::= WHILE Expresion:e DO InstOp:i ENDWHILE
    {:RESULT = sem.instruccion_while(e, i);:};
Inst ::= READ Expresion: e
    {:RESULT = sem.instruccion_read(e);:};
Inst ::= WRITE Expresion:e
    {:RESULT = sem.instruccion_write(e);:};
Inst ::= NL
    {:RESULT = sem.instruccion_nl();:};
Inst ::= NEW Expresion:e
    {:RESULT = sem.instruccion_new(e);:};
Inst ::= DELETE Expresion:e
    {:RESULT = sem.instruccion_delete(e);:};
Inst ::= CALL ID:i paramReales: pr
    {:RESULT = sem.instruccion_call(i, pr);:};
Inst ::= bloque: b
    {:RESULT = sem.instruccion_bloque(b);:};

paramReales ::= PAP expr:e ListaExpresiones:le PCIERRE
    {:RESULT = sem.parRealesAux(e, le);:};
paramReales ::= PAP PCIERRE
    {:RESULT = sem.parReales_ninguna();:};

ListaExpresiones ::= PTOCOMA expr:e ListaExpresiones:le
    {:RESULT = sem.lExpresionesAux(e, le);:};
ListaExpresiones ::= 
    {:RESULT = null;:};

Expresion ::= E0:e 
    {:RESULT = e;:};

E0 ::= E1: a0 MAS E0:a1
    {:RESULT = sem.suma(a0, a1);:};
E0 ::= E1:e MENOS E1:e1
    {:RESULT = sem.resta(e, e1);:};
E0 ::= E1:a
    {:RESULT = a;:};  

E1 ::= E1:a0 OP1:op E2:a1
    {:RESULT = sem.exp(op, a0, a1);:};
E1 ::= E2:a
    {:RESULT = a;:};

E2 ::= E2:a0 OP2:op E3: a1
    {:RESULT = sem.exp(op, a0, a1);:};
E2 ::= E3:a
    {:RESULT = a;:};

E3 ::= E4:a0 OP3:op E4:a1
    {:RESULT = sem.exp(op, a0, a1);:};  
E3 ::= E4:a
    {:RESULT = a;:};


E4 ::= MENOS E5:a
    {:RESULT = sem.neg(a);:};
E4 ::= NOT E4: a
    {:RESULT = sem.not(a);:};
E4 ::= E5:a
    {:RESULT = a;:};

E5 ::= E5:a0 CORABIERTO Expresion:a1 CORCERRADO
    {:RESULT = sem.indice(a0, a1);:};
E5 ::= E5:e PUNTO ID:i
    {:RESULT = sem.punto(e, i);:};
E5 ::= E5:a FLECHA ID: i
    {:RESULT = sem.flecha(a, i);:};
E5 ::= E6:a
    {:RESULT = a;:};

E6 ::= MUL E6:a
    {:RESULT = sem.indir(a);:};
E6 ::= E7:a
    {:RESULT = a;:};

E7 ::= NENT:n
    {:RESULT = sem.nEntero(n);:};
E7 ::= NREAL: n
    {:RESULT = sem.nReal(n);:};
E7 ::= ID: i
    {:RESULT = sem.id(i);:};
E7 ::= NULL
    {:RESULT = sem.nulo();:};
E7 ::= LITERALCAD:l
    {:RESULT = sem.literalCad(l);:};
E7 ::= TRUE
    {:RESULT = sem.cierto();:};
E7 ::= FALSE
    {:RESULT = sem.falso();:};
E7 ::= PAP E0:a PCIE
    {:RESULT = a;:};

OP1 ::= AND
    {:RESULT = "and";:};
OP1 ::= OR
    {:RESULT = "or";:};

OP2 ::= MAYOR
    {:RESULT = ">";:};
OP2 ::= MENOR
    {:RESULT = "<";:};
OP2 ::= MAYORIGUAL
    {:RESULT = ">=";:};
OP2 ::= MENORIGUAL
    {:RESULT = "<=";:};
OP2 ::= COMPARACION
    {:RESULT = "==";:};
OP2 ::= DISTINTO
    {:RESULT = "!=";:};

OP3 ::= MUL
    {:RESULT = "*";:};
OP3 ::= DIV
    {:RESULT = "/";:};
OP3 ::= MODULO
    {:RESULT = "%";:};

